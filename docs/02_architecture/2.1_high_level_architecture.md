# Phase 2.1 – High-Level Architecture

## 1. Purpose

This document defines the **high-level system architecture** of EventFlow. It explains **what major components exist**, **why they exist**, and **how they interact** — without going into low-level implementation details.

The goal is to provide a clear mental model of the system before any code is written.

---

## 2. Architectural Principles

EventFlow is designed using the following principles:

* **Separation of Concerns** – Each component has a single responsibility
* **Event-Centric Design** – Events are immutable and first-class citizens
* **Loose Coupling** – Producers and consumers do not depend on each other directly
* **Extensibility** – Easy to add analytics, streaming, or ML later
* **Simplicity First** – MVP avoids unnecessary complexity

---

## 3. High-Level Components Overview

The system is composed of the following major components:

1. Frontend (Web Dashboard)
2. API Gateway / Backend Service
3. Event Ingestion Layer
4. Event Store (Database)
5. Event Dispatcher
6. Consumer Services (Internal)
7. Observability & Logging
8. Cloud Infrastructure

---

## 4. Component Breakdown

### 4.1 Frontend – Web Dashboard (Next.js)

**Purpose:**

* Acts as the user-facing interface
* Allows users to:

  * Register event producers
  * View incoming events
  * Track event lifecycle and status

**Responsibilities:**

* UI rendering
* User authentication
* Event visualization
* API interaction only (no direct DB access)

**Why it exists:**
Provides visibility and control over the event-driven system.

---

### 4.2 Backend API Service

**Purpose:**

* Serves as the central entry point for all requests

**Responsibilities:**

* Authentication & authorization
* Input validation
* Business logic orchestration
* API exposure for frontend and producers

**Why it exists:**
Prevents direct coupling between frontend, producers, and internal systems.

---

### 4.3 Event Ingestion Layer

**Purpose:**

* Accepts events from producers

**Responsibilities:**

* Validate event structure
* Enrich events with metadata (timestamp, ID, source)
* Persist events reliably

**Why it exists:**
Separates raw input handling from internal processing logic.

---

### 4.4 Event Store (Database)

**Purpose:**

* Stores all events immutably

**Characteristics:**

* Append-only
* Schema-aware
* Queryable by time, type, source

**Why it exists:**
Acts as the **single source of truth** for the system.

---

### 4.5 Event Dispatcher

**Purpose:**

* Routes stored events to internal consumers

**Responsibilities:**

* Reads from the event store
* Delivers events asynchronously
* Ensures retry and failure tracking

**Why it exists:**
Decouples event storage from event processing.

---

### 4.6 Consumer Services (Internal)

**Purpose:**

* Perform actions based on events

**Examples:**

* Notification service
* Audit logger
* Analytics pipeline (future)

**Why it exists:**
Allows independent evolution of features without impacting producers.

---

### 4.7 Observability & Logging

**Purpose:**

* Provide insight into system behavior

**Includes:**

* Application logs
* Event traces
* Error monitoring

**Why it exists:**
Debuggability is critical in event-driven systems.

---

### 4.8 Cloud Infrastructure

**Purpose:**

* Hosts and runs the system reliably

**Includes:**

* Compute
* Networking
* Storage
* CI/CD pipelines

**Why it exists:**
Demonstrates real-world deployment readiness.

---

## 5. High-Level Data Flow

1. Producer sends event → Backend API
2. Backend validates and enriches event
3. Event is stored in Event Store
4. Dispatcher reads new event
5. Consumers process event asynchronously
6. Frontend reflects event status

---

## 6. Open Ends for Future Phases

* Stream processing engines
* Data warehouse integration
* Real-time analytics dashboards
* ML-based anomaly detection