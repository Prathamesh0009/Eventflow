# Phase 2.5 – Cloud Architecture & Deployment Design

## 1. Purpose

This document defines **how EventFlow is deployed and operated in the cloud**. It maps system components to **AWS services**, explains **networking, environments, and deployment strategy**, and ensures alignment with scalability, cost, and reliability goals.

This is a **design-level document**, not an IaC implementation.

---

## 2. Cloud Design Principles

* **Minimal but realistic AWS usage**
* **Cost-aware MVP architecture**
* **Environment parity** (local ≈ cloud)
* **Infrastructure as code ready**
* **No premature over-engineering**

---

## 3. Cloud Provider Choice

### AWS (Amazon Web Services)

**Reasons:**

* Strong presence in Germany
* Widely used by startups, SMEs, and enterprises
* Excellent learning + certification ecosystem
* Aligns with backend + data growth plans

---

## 4. Environment Strategy

| Environment | Purpose                  |
| ----------- | ------------------------ |
| Local       | Development & testing    |
| Staging     | Integration & validation |
| Production  | Live system              |

All environments follow **the same architecture**, differing only in scale.

---

## 5. High-Level Cloud Architecture

### Core Components on AWS

* Application Load Balancer (ALB)
* Backend API Service (Docker)
* Frontend (Next.js)
* PostgreSQL (RDS)
* Redis
* Logging & Monitoring

---

## 6. Networking Design

### 6.1 VPC (Virtual Private Cloud)

* One VPC per environment
* CIDR-based isolation

### 6.2 Subnets

* Public Subnet:

  * Load Balancer
* Private Subnet:

  * Backend services
  * Database
  * Redis

### 6.3 Security Groups

* Restrictive inbound rules
* Least-privilege access

---

## 7. Compute Layer

### 7.1 Backend API

**Option (MVP):**

* ECS (EC2 launch type) or single EC2

**Responsibilities:**

* API handling
* Event ingestion
* Dispatch logic

**Scaling:**

* Horizontal scaling via container replicas

---

### 7.2 Frontend (Next.js)

**Deployment Options:**

* Vercel (external)
* AWS (EC2 / ECS)

**MVP Choice:**

* Keep frontend and backend separately deployable

---

## 8. Data Layer

### 8.1 PostgreSQL (AWS RDS)

**Why RDS:**

* Managed backups
* Automatic patching
* Easy scaling

**Configuration:**

* Single AZ (MVP)
* Automated snapshots

---

### 8.2 Redis

**Purpose:**

* Event buffering
* Rate limiting

**Options:**

* Self-hosted (EC2)
* AWS ElastiCache (future)

---

## 9. Observability & Monitoring

### 9.1 Logging

* Application logs → CloudWatch
* Structured JSON logs

### 9.2 Metrics

* CPU / memory
* Request latency
* Event throughput

### 9.3 Alerts (Future)

* Error rate spikes
* Resource exhaustion

---

## 10. CI/CD Pipeline

### GitHub Actions

**Pipeline Stages:**

1. Code checkout
2. Lint & test
3. Build Docker image
4. Push to registry
5. Deploy to AWS

---

## 11. Infrastructure as Code (Future-Ready)

* Terraform planned
* Modules per environment
* Version-controlled infra

---

## 12. Cost Awareness (MVP)

Design choices made to:

* Use minimal instances
* Avoid managed services initially
* Scale only when required

---

## 13. Backup & Disaster Recovery Strategy

### 13.1 Backup Strategy

**Database Backups (RDS):**
* **Automated daily snapshots** - Retained for 7 days
* **Point-in-time recovery (PITR)** - Enabled with 7-day retention
* **Manual snapshots** - Before major deployments or schema changes
* **Backup window:** Off-peak hours (2-4 AM UTC)

**Application State:**
* Stateless services - No backup needed
* Configuration stored in version control
* Secrets in AWS Secrets Manager (automatically backed up)

**Redis:**
* Snapshot to S3 (daily)
* RDB persistence enabled

### 13.2 Recovery Objectives

* **RTO (Recovery Time Objective):** 4 hours
* **RPO (Recovery Point Objective):** 1 hour (last backup)

### 13.3 Disaster Recovery Procedures

**Scenario 1: Database Failure**
1. Restore from latest snapshot
2. Point-in-time recovery to last known good state
3. Verify data integrity
4. Restart application services

**Scenario 2: Region Failure**
1. Restore RDS snapshot in secondary region
2. Deploy application infrastructure (Terraform)
3. Update DNS to point to new region
4. Estimated recovery time: 4-6 hours

**Scenario 3: Application Corruption**
1. Rollback to previous Docker image version
2. Restart ECS services
3. Verify health endpoints
4. Estimated recovery time: 15-30 minutes

### 13.4 Backup Testing

* **Monthly:** Test restore from snapshot
* **Quarterly:** Full disaster recovery drill
* **Documentation:** Recovery procedures documented and version-controlled

### 13.5 High Availability (Future)

For production scale:
* Multi-AZ RDS deployment
* Application load balancer across multiple AZs
* Auto-scaling groups for redundancy